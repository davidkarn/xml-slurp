; A library for parsing xml/html while being tolerant of common errors and malformed
; syntax. Parse-xml should return the most representative tree possible of any input, and 
; never throw an error.

(define *single-tags*
  '("br" "input" "img" "option" "script" "link" "meta" "!DOCTYPE"))

(define *verbatim-tags*
  '("script" "style" "pre"))

(define *xml-entities*
  '(("&quote;" . "\"")
    ("&apos;" . "'")
    ("&amp;" . "&")))

(define (fix-xml-entities str)
  (string-substitute* str *xml-entities*))

(define (new-xml-tag tag attrs children)
  (list tag attrs children))

(define (xml-tag:tag? x)
  (and (list? x)
       (not-empty? x)
       (equal? (length x) 3)
       (string? (first x))
       (list? (second x))
       (list? (third x))))
(define (list-nth lis nth . def)
  (if (and (list? lis) (>= (length lis) nth))
      (car (drop lis (- nth 1)))
      (if (empty? def) #f (car def))))
(define xml-tag:tag (delay-function list-nth #f 1 ""))
(define xml-tag:attrs (delay-function list-nth #f 2 '()))
(define xml-tag:children (delay-function list-nth #f 3 '()))
(define xml-tag:parent (delay-function list-nth #f 4 '()))
(define (xml-tag:attr-matching tag a)
  (if (string? tag) 
      tag
      (let ((r (xml-tag:attrs tag)))
        (let ((r2 (assoc (->string a) r)))
          (if (not r2) ""
              (cdr r2))))))
(define (xml-tag:child-matching tag a)
  (let ((r (xml-tag:children-matching tag a)))
    (if (empty? r) '() (car r))))
(define (xml-tag:children-matching tag a)
  (filter (lambda (x) (and (list? x) (not-empty? x) (equal? (car x) a))) (xml-tag:children tag)))
(define (xml-text x)
  (if (string? x)
      x
      (xml-tag:to-text x)))
(define (xml-tag:to-text tag)
  (if (and (member (xml-tag:tag tag) *single-tags* string-ci=)
	   (empty? (xml-tag:children tag)))
      (string-append "<" (xml-tag:tag tag) 
		     (string-join (map (lambda (x)
					 (string-append (car x) "=\"" (cdr x) "\"")) (xml-tag:attrs tag))
				  " " 'prefix)
		     " />")
      (string-append "<" (xml-tag:tag tag) 
		     (string-join (map (lambda (x)
					 (string-append (car x) "=\"" (cdr x) "\"")) (xml-tag:attrs tag))
				  " " 'prefix)
		     ">"
		     (xml-tag:innertext tag)
		     "</" (xml-tag:tag tag) ">")))

(define (xml-tag:innertext tag)
  (if (and (list? tag) (not (empty? tag)))
      (string-join (map xml-text (xml-tag:children tag)) "")
      (if (string? tag) tag "")))

(define *xml-attribute-regex* "\\s*([-_a-zA-Z.:0-9]+)(=([^ \r\t\n\"'>]+|\"(\\\"|[^\"])*\"|'(\\\'|[^'])*'))?")
(define *xml-attribute-regex2* "\\s+([-_a-zA-Z:0-9]+)(?:\\=(([^ \r\t\n\"'>]+)|\"([^\"]*)?\"|'([^']*)?'))?")
(define *xml-tag-regex* (string-append "\\s*<\\s*[!#?$@]?\\s*[-_a-z.:0-9A-Z]+(\\s|(" *xml-attribute-regex* ")*?)\\s*/\\s*>\\s*"))
(define *xml-tag-regex* (string-append "\\s*<\\s*[!-_a-z.:0-9A-Z]+?\\s*(" *xml-attribute-regex* ")*?\\s*/\\s*>\\s*"))
					;(define *xml-starttag-regex* (string-append "\\s*<\\s*!?[-_a-z:0-9A-Z]+(\\s*>|(" *xml-attribute-regex* ")*\\s*>)?\\s*"))
(define *xml-starttag-regex* (string-append "\\s*<[-_a-z.:0-9A-Z]+(\\s*|(" *xml-attribute-regex* ")+)\\s*>"))
(define *xml-starttag-test-regex* (string-append "\\s*<\\s*!?[-_a-z:0-9A-Z]+\\s*"))
(define *xml-cdata-regex* "\\s*<!\\[cdata\\[(.*?)\\]\\]>\\s*")
(define *xml-comment-regex* "\\s*<!--(.*?)-->\\s*")
(define *xml-endtag-regex* "\\s*<\\s*/\\s*([-!_:a-zA.-Z0-9]+)\\s*>\\s*")
(define *xml-text-regex* (string-append "(.*?\\s*)(?=$|" *xml-tag-regex* "|"
                                        *xml-starttag-regex* "|" *xml-cdata-regex* "|"
                                        *xml-comment-regex* "|" *xml-endtag-regex* ")"))
(define *xml-text-regex* "(.*?\\s*)(?=$|</?[-_a-zA-Z0-9$#@!]+(\\s|=|>))")

(define (multiline . x)
  (regexp
   (apply string-append x) #t #t))


(define multiline (memoize multiline))


(define (xml-tag? str)
  (string-search (multiline "^" *xml-tag-regex*) str))
					;(define (xml-single-tag? str)
					;  (not (empty? (filter (lambda (x) (string-search (multiline "^\\s*<\\s*" x "(\\s*>|" *xml-attribute-regex*")*-*/?\\s*>") str))
					;                       *single-tags*))))

(define (xml-single-tag? str)
  (if (equal? (string-ref str 0) #\<)
      (let* ((res (string-trim (string-drop str 1)))
             (res2 (filter self (map (lambda (a)  (if (string-prefix-ci? a res)
                                                      (let ((r(string-ref str
									  (+ (string-length a) 1))))
                                                        (if (or (equal? r #\space)
                                                                (equal? r #\>)
                                                                (equal? r #\/))
							    #t
							    #f))
                                                      #f))
                                     *single-tags*))))
        (if (empty? res2)
            #f
            (car res2)))
      #f))

(define (xml-tag? str)
  (if (equal? (string-ref str 0) #\<)
      (let* ((res (string-trim (string-drop str 1)))
             (res2 (string-word res ""))
             (res3 (parse-xml-attributes (string-trim (cdr res2)))))
        (if (and (not (equal? "" (car res2)))
                 (equal? (string-ref (string-trim (cdr res3)) 0) #\/))
            #t
            #f))
      #f))

(define (xml-verbatim-tag? str)
  (if (equal? (string-ref str 0) #\<)
      (let* ((res (string-trim (string-drop str 1)))
             (res2 (filter self (map (lambda (a)  (if (string-prefix-ci? a res)
                                                      (let ((r(string-ref str
									  (+ (string-length a) 1))))
                                                        (if (or (equal? r #\space)
                                                                (equal? r #\>))
							    #t
							    #f))
                                                      #f))
                                     *verbatim-tags*))))
        (if (empty? res2)
            #f
            (car res2)))
      #f))

(define (xml-single-tag2? str)                                      
  (string-search *single-tag?-regex*
                 str))
(define (xml-starttag? str)
  (string-search (multiline "^" *xml-starttag-test-regex*) str))
(define (xml-endtag? str)
  (and (equal? (string-ref str 0) #\<)
       (or (equal? (string-ref str 1) #\/)
           (and (equal? (string-ref str 1) #\space)
                (equal? (string-ref str 2) #\/)))))
(define (xml-cdata? str)
  (equal? (string-upcase (stream->substring str 0 9)) 
	  "[CDATA["))
(define (xml-comment? str)
  (equal?  (stream->substring str 0 4)
	   "<!--"))

(define (do-unquote str)
  (let ((str (if (member (string-take str 1) '("'" "\""))
                 (string-drop str 1)
                 str)))
    (if (member (string-take-right str 1) '("'" "\""))
        (string-drop-right str 1)
        str)))

(define (xml-get-endtag str)
  (cadr (string-search "^\\s*<\\s*/\\s*([-a-zA-Z0-9.:]+)" str)))

(define (parse-xml-single-tag str)
  (let* ((tag (second-and-after-regex (multiline "\\s*<\\s*([-_a-z0-9A-Z:]+)") str))
         (attrs (parse-xml-attributes (cadr tag))))
    (cons (new-xml-tag (car tag) (car attrs) '()) (after-regex (multiline"\\s*<\\s*!?[-_a-z:0-9A-Z].(\\s*([-a-zA-Z0-9]+(\\s*|='[^']'|=\"[^\"]|[^ \r\n\t]+)\\s*>)+/?\\s*>|.*?/?\\s*>)?") str))))

(define (parse-xml-verbatim-tag str)
  (let* ((tag (second-and-after-regex (multiline "\\s*<\\s*([-_a-z0-9A-Z:]+)") str))
         (attrs (parse-xml-attributes (cadr tag)))
         (r (string-search-positions (multiline ".*?>(.*?)<\\s*/\\s*" (car tag) "\\s*>") (cdr attrs)))
         (text (substring/shared (cdr attrs) (caadr r) (cadadr r)))
         (rest (string-drop (cdr attrs) (cadar r))))
    (cons (new-xml-tag (car tag) (car attrs) (list text)) rest)))

(define (parse-xml-cdata str)
  (cons (cadr (string-search (multiline *xml-cdata-regex*) str))
        (after-regex (multiline *xml-cdata-regex*) str)))

(define (parse-xml-comment str)
  (cons
   '("!--" () ()) (after-regex (multiline *xml-comment-regex*) str)))

(define (parse-xml-text str)
  (cons (fix-xml-entities (cadr (string-search (multiline *xml-text-regex*) str)))
        (after-regex (multiline *xml-text-regex*) str)))

(define (parse-xml-text str)
  (let ((r(second-and-after-regex (multiline *xml-text-regex*) str)))
    (cons (car r) (second r))))

(define (parse-xml-text str)
  (let ((index (stream-charset-index str (char-set #\<))))
    (if (not index)
        (cons (stream->string str) (stream))
        (cons (stream->substring str 0 index) (substream-from str index)))))

(define (stream->string str)
  (let ((i (stream-eq-index str #!eof)))
    (car str)))

					;(define (string->stream str)
					;  (call-with-input-string str (lambda (p) (cons "" p))))

(define (parse-xml-tag str)
  (let* ((tag (cadr (string-search (multiline "\\s*<\\s*[!#?$@]?([-_a-z0-9A-Z:]+)") str)))
         (attrs (parse-xml-attributes (after-regex (multiline "\\s*<\\s*[!#?$@]?[-_:a-z0-9A-Z]*") str))))
    (if (equal? tag "")
        (after-regex (multiline *xml-tag-regex*) str)
        (cons (new-xml-tag tag (car attrs) '()) (after-regex (multiline *xml-tag-regex*) str)))))

(define (parse-xml-block str tags)
  (let* ((tag (cadr (string-search (multiline "<([-_:a-z0-9A-Z]+)") str)))
         (attrs (parse-xml-attributes (after-regex (multiline "\\s*<\\s*[-_:a-z0-9A-Z]*") str)))
         (children (parse-xml-body (after-regex (multiline ".*?>") (cdr attrs)) (cons tag tags))))
    (if (equal? tag "")
        (car children)
        (cons (new-xml-tag tag (car attrs) (car children)) (if (string? (cdr children))
                                                               (cdr children)
                                                               "")))))

(define (parse-xml-block str tags)
  (let ((r (second-and-after-regex (multiline "\\s*<\\s*([-_:a-z0-9A-Z]+)") str)))
    (if (string= (car r) "")
        (car (parse-xml-body (after-regex (multiline *xml-starttag-regex*) str) tags))
        (let ((tag (car r))
              (children (parse-xml-body (after-regex (multiline *xml-starttag-regex*) str)
					(cons (car r) tags)))
              (attrs (parse-xml-attributes (cadr r))))
          (cons (new-xml-tag (car r) (car attrs) (car children))
                (if (string? (cdr children)) (cdr children) ""))))))

(define (parse-xml-block str tags)
  (let* ((res (string-trim (string-drop (string-trim str) 1)))
         (res2 (string-word res ""))
         (res3 (parse-xml-attributes (string-trim (cdr res2))))
         (cdres3 (string-trim (cdr res3)))
         (cdres4  (string-drop (if (equal? (string-ref cdres3 0) #\/)
                                   (string-trim (string-drop cdres3 1))
                                   cdres3) 1))
         (children (parse-xml-body cdres4 (cons (car res2) tags))))
    (if (string? (cdr children))
        (cons (list (car res2) (car res3) (car children))
              (cdr children))
        (cons (list (car res2) (car res3) (car children))
              ""))))

(define (parse-xml-block tag attributes rest tags)
  (let* ((children (parse-xml-body rest (cons tag tags))))
    (cons (list tag attributes (car children))
	  (cdr children))))

(define (parse-xml-attributes str)
  (if str
      (let ((r (string-search (multiline "^" *xml-attribute-regex*) str)))
        (if (not r)
            (cons '() str)
            (pxa-helper (cons (cadr r) (if (caddr r) (fix-xml-entities (do-unquote (caddr r))) "true"))
                        (parse-xml-attributes (after-regex (multiline *xml-attribute-regex*) str)))))
      '()))

(define (parse-xml-attributes str)
  (let ((r (string-search (multiline "^" *xml-attribute-regex2*) str)))
    (if (not r)
        (cons '() str)
        (let ((rest (parse-xml-attributes (string-drop str (string-length (car r)))))
              (attr (cadr r))
              (val (if (fourth r) (fourth r) (if (fifth r) (fifth r) (if (sixth r) (sixth r) "true")))))
	  (pxa-helper (cons attr (fix-xml-entities val))
		      rest)))))

(define (parse-xml-attributes str)
  (parse-all-attributes str '()))

(define (parse-all-attributes str attrs)
  (let ((word (stream-word! str "")))
    (if (string= (car word) "")
        (cons attrs str)
        (let ((word (car word))
              (rest (cdr word)))
          (if (equal? (stream-car rest) #\=)
              (let ((value (stream-quote (substream-from rest 1))))
                (parse-all-attributes (stream-trim-all! (cdr value)) (cons (cons word (car value)) attrs)))
              (parse-all-attributes (stream-trim-all! rest) (cons (cons word "true") attrs)))))))

(define (pxa-helper a b)
  (cons (cons a (car b))
        (cdr b)))

(define (remove-xml-tagend str)
  (string-drop str (cadar (string-search-positions "[ \r\n\t]*>" str))))


(define (parse-xml-body stream tags)
  (if (not (stream-occupied? stream))
      '(())
      (begin
	(stream-clean! stream)

	(let ((stream (stream-trim-all! stream)))
	  (if (not (stream-occupied? stream))
	      '(())
	      (if (equal? (stream-car stream) #\<)
		  (let* ((stream (stream-trim-all! (substream-from stream 1)))
			 (first (stream-car stream)))
		    (if (equal? first #\/)
			(let* ((tag (stream-word! (stream-trim-all! (substream-from stream 1)) ""))
			       (rest (stream-after! (cdr tag) #\>))
			       (tag (car tag)))
			  (cond ((and (not-empty? tags) (string-ci= tag (car tags)))
				 (cons '() rest))
				((member tag tags)
				 (cons '() (stream-prefix (string-concatenate (list "</" tag ">")) rest)))
				(#t (parse-xml-body rest tags))))
			(if (equal? first #\!)
			    (let* ((stream (stream-clean! (substream-from stream 1)))
				   (first (stream-car stream)))
			      (cond ((and (equal? first #\[)
					  (xml-cdata? stream))
				     (let* ((r (parse-xml-cdata stream))
					    (rest (parse-xml-body (cdr r) tags)))
				       (cons (cons (car r) (car rest)) (cdr rest))))
				    ((and (equal? first #\-)
					  (equal? (stream-ref stream 1) #\-))
				     (let ((rest (parse-xml-body (stream-after-prefix stream "-->") tags)))
				       (cons (cons '("!--" () ())
						   (car rest))
					     (cdr rest))))
				    (#t
				     (let* ((tag (stream-word! stream ""))
					    (attributes (parse-xml-attributes (stream-trim-all! (cdr tag))))
					    (tag (string-concatenate (list "!" (car tag))))
					    (rest (parse-xml-body (stream-after! (cdr attributes) #\>) tags))
					    (attributes (car attributes)))
				       (cons (cons (new-xml-tag tag attributes '()) (car rest)) (cdr rest))))))
			    (let* ((tag (stream-word! (substream-from-port! stream) ""))
				   (attributes (parse-xml-attributes (stream-trim-all! (cdr tag))))
				   (tag (car tag))
				   (rest (stream-trim-all! (cdr attributes)))
				   (attributes (car attributes)))
			      (cond ((member tag *verbatim-tags* string-ci=)
				     (let* ((str2 (stream-after! rest #\>))
					    (r (stream-before-pattern (list #\< 'whitespace #\/ 'whitespace tag 'whitespace #\>) str2))
					    (rest (parse-xml-body (cdr r) tags)))
				       (cons (cons (new-xml-tag tag attributes (list (car r))) (car rest)) (cdr rest))))
				    ((or (member tag *single-tags* string-ci=)
					 (equal? (stream-car rest) #\/))
				     (let ((rest (parse-xml-body (stream-after! rest #\>) tags)))
				       (cons (cons (new-xml-tag tag attributes '())
						   (car rest))
					     (cdr rest))))
				    (#t
				     (let* ((r (parse-xml-block tag attributes (stream-after! rest #\>) tags))
					    (rest (parse-xml-body (cdr r) tags)))
				       (cons (cons (car r) (car rest)) (cdr rest)))))))))
		  (let* ((r (parse-xml-text stream))
			 (rest (parse-xml-body (cdr r) tags)))
		    (cons (cons (car r) (car rest)) (cdr rest)))))))))

(define (parse-xml stream)
  (new-xml-tag "xml-document" '() (car (parse-xml-body stream '()))))

(define (file-parse path)
  (call-with-input-pipe (string-concatenate (list "cat \"" path "\""))
			(lambda (port)
			  (parse-xml (list "" port)))))

(define (http-parse url)
  (call-with-values (lambda () (process "curl" (list url "-L" "-k")))
    (lambda (in out id)
      (process-wait id)
      (parse-xml (list "" in)))))
